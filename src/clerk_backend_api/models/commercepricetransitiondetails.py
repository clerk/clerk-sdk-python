"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .billingpriceresponse import BillingPriceResponse, BillingPriceResponseTypedDict
from .schemas_commerceplan import SchemasCommercePlan, SchemasCommercePlanTypedDict
from clerk_backend_api.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
from enum import Enum
from pydantic import model_serializer
from typing_extensions import NotRequired, TypedDict


class EffectiveMode(str, Enum):
    r"""When the new price takes effect."""

    IMMEDIATE = "immediate"
    END_OF_PERIOD = "end_of_period"


class ImmediateChargeTypedDict(TypedDict):
    r"""Amount charged immediately, if any."""

    amount: int
    r"""The amount in cents."""
    amount_formatted: str
    r"""The formatted amount as a string (e.g., \"$49.99\")."""
    currency: str
    r"""The currency code (e.g., \"USD\")."""
    currency_symbol: str
    r"""The currency symbol (e.g., \"$\")."""


class ImmediateCharge(BaseModel):
    r"""Amount charged immediately, if any."""

    amount: int
    r"""The amount in cents."""

    amount_formatted: str
    r"""The formatted amount as a string (e.g., \"$49.99\")."""

    currency: str
    r"""The currency code (e.g., \"USD\")."""

    currency_symbol: str
    r"""The currency symbol (e.g., \"$\")."""


class PreviousSubscriptionItemStatus(str, Enum):
    r"""The status of the previous subscription item after transition."""

    CANCELED = "canceled"
    ENDED = "ended"
    ABANDONED = "abandoned"


class CommercePriceTransitionDetailsTypedDict(TypedDict):
    previous_plan: SchemasCommercePlanTypedDict
    previous_price: BillingPriceResponseTypedDict
    effective_at: int
    r"""Unix timestamp (milliseconds) when the new price takes effect."""
    effective_mode: EffectiveMode
    r"""When the new price takes effect."""
    charged_immediately: bool
    r"""Whether an immediate charge was made."""
    previous_subscription_item_status: PreviousSubscriptionItemStatus
    r"""The status of the previous subscription item after transition."""
    previous_subscription_item_id: str
    r"""The ID of the previous subscription item."""
    next_billing_date: NotRequired[Nullable[int]]
    r"""Unix timestamp (milliseconds) for the next billing date."""
    immediate_charge: NotRequired[Nullable[ImmediateChargeTypedDict]]
    r"""Amount charged immediately, if any."""


class CommercePriceTransitionDetails(BaseModel):
    previous_plan: SchemasCommercePlan

    previous_price: BillingPriceResponse

    effective_at: int
    r"""Unix timestamp (milliseconds) when the new price takes effect."""

    effective_mode: EffectiveMode
    r"""When the new price takes effect."""

    charged_immediately: bool
    r"""Whether an immediate charge was made."""

    previous_subscription_item_status: PreviousSubscriptionItemStatus
    r"""The status of the previous subscription item after transition."""

    previous_subscription_item_id: str
    r"""The ID of the previous subscription item."""

    next_billing_date: OptionalNullable[int] = UNSET
    r"""Unix timestamp (milliseconds) for the next billing date."""

    immediate_charge: OptionalNullable[ImmediateCharge] = UNSET
    r"""Amount charged immediately, if any."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["next_billing_date", "immediate_charge"])
        nullable_fields = set(["next_billing_date", "immediate_charge"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m
