"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from clerk_backend_api import models, utils
from clerk_backend_api._hooks import HookContext
from clerk_backend_api.types import OptionalNullable, UNSET
from clerk_backend_api.utils.unmarshal_json_response import unmarshal_json_response
from datetime import datetime
from typing import Any, Mapping, Optional


class Billing(BaseSDK):
    def list_plans(
        self,
        *,
        paginated: Optional[bool] = None,
        limit: Optional[int] = 10,
        offset: Optional[int] = 0,
        payer_type: Optional[models.PayerType] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PaginatedCommercePlanResponse:
        r"""List all billing plans

        Returns a list of all billing plans for the instance. The plans are returned sorted by creation date,
        with the newest plans appearing first. This includes both free and paid plans. Pagination is supported.

        :param paginated: Whether to paginate the results.
            If true, the results will be paginated.
            If false, the results will not be paginated.
        :param limit: Applies a limit to the number of results returned.
            Can be used for paginating the results together with `offset`.
        :param offset: Skip the first `offset` results when paginating.
            Needs to be an integer greater or equal to zero.
            To be used in conjunction with `limit`.
        :param payer_type: Filter plans by payer type
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetCommercePlanListRequest(
            paginated=paginated,
            limit=limit,
            offset=offset,
            payer_type=payer_type,
        )

        req = self._build_request(
            method="GET",
            path="/billing/plans",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 60000, 1.5, 3600000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["5XX"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetCommercePlanList",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "401", "422", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.PaginatedCommercePlanResponse, http_res
            )
        if utils.match_response(http_res, ["400", "401", "422"], "application/json"):
            response_data = unmarshal_json_response(models.ClerkErrorsData, http_res)
            raise models.ClerkErrors(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(models.ClerkErrorsData, http_res)
            raise models.ClerkErrors(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)

        raise models.SDKError("Unexpected response received", http_res)

    async def list_plans_async(
        self,
        *,
        paginated: Optional[bool] = None,
        limit: Optional[int] = 10,
        offset: Optional[int] = 0,
        payer_type: Optional[models.PayerType] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PaginatedCommercePlanResponse:
        r"""List all billing plans

        Returns a list of all billing plans for the instance. The plans are returned sorted by creation date,
        with the newest plans appearing first. This includes both free and paid plans. Pagination is supported.

        :param paginated: Whether to paginate the results.
            If true, the results will be paginated.
            If false, the results will not be paginated.
        :param limit: Applies a limit to the number of results returned.
            Can be used for paginating the results together with `offset`.
        :param offset: Skip the first `offset` results when paginating.
            Needs to be an integer greater or equal to zero.
            To be used in conjunction with `limit`.
        :param payer_type: Filter plans by payer type
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetCommercePlanListRequest(
            paginated=paginated,
            limit=limit,
            offset=offset,
            payer_type=payer_type,
        )

        req = self._build_request_async(
            method="GET",
            path="/billing/plans",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 60000, 1.5, 3600000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["5XX"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetCommercePlanList",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "401", "422", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.PaginatedCommercePlanResponse, http_res
            )
        if utils.match_response(http_res, ["400", "401", "422"], "application/json"):
            response_data = unmarshal_json_response(models.ClerkErrorsData, http_res)
            raise models.ClerkErrors(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(models.ClerkErrorsData, http_res)
            raise models.ClerkErrors(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)

        raise models.SDKError("Unexpected response received", http_res)

    def list_subscription_items(
        self,
        *,
        paginated: Optional[bool] = None,
        limit: Optional[int] = 10,
        offset: Optional[int] = 0,
        status: Optional[models.GetCommerceSubscriptionItemListQueryParamStatus] = None,
        payer_type: Optional[models.QueryParamPayerType] = None,
        plan_id: Optional[str] = None,
        include_free: Optional[bool] = False,
        query: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PaginatedCommerceSubscriptionItemResponse:
        r"""List all subscription items

        Returns a list of all subscription items for the instance. The subscription items are returned sorted by creation date,
        with the newest appearing first. This includes subscriptions for both users and organizations. Pagination is supported.

        :param paginated: Whether to paginate the results.
            If true, the results will be paginated.
            If false, the results will not be paginated.
        :param limit: Applies a limit to the number of results returned.
            Can be used for paginating the results together with `offset`.
        :param offset: Skip the first `offset` results when paginating.
            Needs to be an integer greater or equal to zero.
            To be used in conjunction with `limit`.
        :param status: Filter subscription items by status
        :param payer_type: Filter subscription items by payer type
        :param plan_id: Filter subscription items by plan ID
        :param include_free: Whether to include free plan subscription items
        :param query: Search query to filter subscription items
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetCommerceSubscriptionItemListRequest(
            paginated=paginated,
            limit=limit,
            offset=offset,
            status=status,
            payer_type=payer_type,
            plan_id=plan_id,
            include_free=include_free,
            query=query,
        )

        req = self._build_request(
            method="GET",
            path="/billing/subscription_items",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 60000, 1.5, 3600000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["5XX"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetCommerceSubscriptionItemList",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "401", "422", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.PaginatedCommerceSubscriptionItemResponse, http_res
            )
        if utils.match_response(http_res, ["400", "401", "422"], "application/json"):
            response_data = unmarshal_json_response(models.ClerkErrorsData, http_res)
            raise models.ClerkErrors(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(models.ClerkErrorsData, http_res)
            raise models.ClerkErrors(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)

        raise models.SDKError("Unexpected response received", http_res)

    async def list_subscription_items_async(
        self,
        *,
        paginated: Optional[bool] = None,
        limit: Optional[int] = 10,
        offset: Optional[int] = 0,
        status: Optional[models.GetCommerceSubscriptionItemListQueryParamStatus] = None,
        payer_type: Optional[models.QueryParamPayerType] = None,
        plan_id: Optional[str] = None,
        include_free: Optional[bool] = False,
        query: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PaginatedCommerceSubscriptionItemResponse:
        r"""List all subscription items

        Returns a list of all subscription items for the instance. The subscription items are returned sorted by creation date,
        with the newest appearing first. This includes subscriptions for both users and organizations. Pagination is supported.

        :param paginated: Whether to paginate the results.
            If true, the results will be paginated.
            If false, the results will not be paginated.
        :param limit: Applies a limit to the number of results returned.
            Can be used for paginating the results together with `offset`.
        :param offset: Skip the first `offset` results when paginating.
            Needs to be an integer greater or equal to zero.
            To be used in conjunction with `limit`.
        :param status: Filter subscription items by status
        :param payer_type: Filter subscription items by payer type
        :param plan_id: Filter subscription items by plan ID
        :param include_free: Whether to include free plan subscription items
        :param query: Search query to filter subscription items
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetCommerceSubscriptionItemListRequest(
            paginated=paginated,
            limit=limit,
            offset=offset,
            status=status,
            payer_type=payer_type,
            plan_id=plan_id,
            include_free=include_free,
            query=query,
        )

        req = self._build_request_async(
            method="GET",
            path="/billing/subscription_items",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 60000, 1.5, 3600000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["5XX"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetCommerceSubscriptionItemList",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "401", "422", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.PaginatedCommerceSubscriptionItemResponse, http_res
            )
        if utils.match_response(http_res, ["400", "401", "422"], "application/json"):
            response_data = unmarshal_json_response(models.ClerkErrorsData, http_res)
            raise models.ClerkErrors(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(models.ClerkErrorsData, http_res)
            raise models.ClerkErrors(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)

        raise models.SDKError("Unexpected response received", http_res)

    def cancel_subscription_item(
        self,
        *,
        subscription_item_id: str,
        end_now: Optional[bool] = False,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.CommerceSubscriptionItem:
        r"""Cancel a subscription item

        Cancel a specific subscription item. The subscription item can be canceled immediately or at the end of the current billing period.

        :param subscription_item_id: The ID of the subscription item to cancel
        :param end_now: Whether to cancel the subscription immediately (true) or at the end of the current billing period (false, default)
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CancelCommerceSubscriptionItemRequest(
            subscription_item_id=subscription_item_id,
            end_now=end_now,
        )

        req = self._build_request(
            method="DELETE",
            path="/billing/subscription_items/{subscription_item_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 60000, 1.5, 3600000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["5XX"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="CancelCommerceSubscriptionItem",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "422", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.CommerceSubscriptionItem, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404", "422"], "application/json"
        ):
            response_data = unmarshal_json_response(models.ClerkErrorsData, http_res)
            raise models.ClerkErrors(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(models.ClerkErrorsData, http_res)
            raise models.ClerkErrors(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)

        raise models.SDKError("Unexpected response received", http_res)

    async def cancel_subscription_item_async(
        self,
        *,
        subscription_item_id: str,
        end_now: Optional[bool] = False,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.CommerceSubscriptionItem:
        r"""Cancel a subscription item

        Cancel a specific subscription item. The subscription item can be canceled immediately or at the end of the current billing period.

        :param subscription_item_id: The ID of the subscription item to cancel
        :param end_now: Whether to cancel the subscription immediately (true) or at the end of the current billing period (false, default)
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CancelCommerceSubscriptionItemRequest(
            subscription_item_id=subscription_item_id,
            end_now=end_now,
        )

        req = self._build_request_async(
            method="DELETE",
            path="/billing/subscription_items/{subscription_item_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 60000, 1.5, 3600000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["5XX"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="CancelCommerceSubscriptionItem",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "422", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.CommerceSubscriptionItem, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404", "422"], "application/json"
        ):
            response_data = unmarshal_json_response(models.ClerkErrorsData, http_res)
            raise models.ClerkErrors(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(models.ClerkErrorsData, http_res)
            raise models.ClerkErrors(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)

        raise models.SDKError("Unexpected response received", http_res)

    def extend_subscription_item_free_trial(
        self,
        *,
        subscription_item_id: str,
        extend_to: datetime,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.SchemasCommerceSubscriptionItem:
        r"""Extend free trial for a subscription item

        Extends the free trial period for a specific subscription item to the specified timestamp.
        The subscription item must be currently in a free trial period, and the plan must support free trials.
        The timestamp must be in the future and not more than 365 days from the end of the current trial period
        This operation is idempotent - repeated requests with the same timestamp will not change the trial period.

        :param subscription_item_id: The ID of the subscription item to extend the free trial for
        :param extend_to: RFC3339 timestamp to extend the free trial to.
            Must be in the future and not more than 365 days from now.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ExtendBillingSubscriptionItemFreeTrialRequest(
            subscription_item_id=subscription_item_id,
            extend_free_trial_request=models.ExtendFreeTrialRequest(
                extend_to=extend_to,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/billing/subscription_items/{subscription_item_id}/extend_free_trial",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.extend_free_trial_request,
                False,
                False,
                "json",
                models.ExtendFreeTrialRequest,
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 60000, 1.5, 3600000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["5XX"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="ExtendBillingSubscriptionItemFreeTrial",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "422", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.SchemasCommerceSubscriptionItem, http_res
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404", "422"], "application/json"
        ):
            response_data = unmarshal_json_response(models.ClerkErrorsData, http_res)
            raise models.ClerkErrors(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(models.ClerkErrorsData, http_res)
            raise models.ClerkErrors(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)

        raise models.SDKError("Unexpected response received", http_res)

    async def extend_subscription_item_free_trial_async(
        self,
        *,
        subscription_item_id: str,
        extend_to: datetime,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.SchemasCommerceSubscriptionItem:
        r"""Extend free trial for a subscription item

        Extends the free trial period for a specific subscription item to the specified timestamp.
        The subscription item must be currently in a free trial period, and the plan must support free trials.
        The timestamp must be in the future and not more than 365 days from the end of the current trial period
        This operation is idempotent - repeated requests with the same timestamp will not change the trial period.

        :param subscription_item_id: The ID of the subscription item to extend the free trial for
        :param extend_to: RFC3339 timestamp to extend the free trial to.
            Must be in the future and not more than 365 days from now.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ExtendBillingSubscriptionItemFreeTrialRequest(
            subscription_item_id=subscription_item_id,
            extend_free_trial_request=models.ExtendFreeTrialRequest(
                extend_to=extend_to,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/billing/subscription_items/{subscription_item_id}/extend_free_trial",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.extend_free_trial_request,
                False,
                False,
                "json",
                models.ExtendFreeTrialRequest,
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 60000, 1.5, 3600000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["5XX"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="ExtendBillingSubscriptionItemFreeTrial",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "422", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.SchemasCommerceSubscriptionItem, http_res
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404", "422"], "application/json"
        ):
            response_data = unmarshal_json_response(models.ClerkErrorsData, http_res)
            raise models.ClerkErrors(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(models.ClerkErrorsData, http_res)
            raise models.ClerkErrors(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)

        raise models.SDKError("Unexpected response received", http_res)

    def list_statements(
        self,
        *,
        paginated: Optional[bool] = None,
        limit: Optional[int] = 10,
        offset: Optional[int] = 0,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PaginatedBillingStatementResponse:
        r"""List all billing statements

        Returns a list of all billing statements for the instance. The statements are returned sorted by creation date,
        with the newest statements appearing first. Pagination is supported.

        :param paginated: Whether to paginate the results.
            If true, the results will be paginated.
            If false, the results will not be paginated.
        :param limit: Applies a limit to the number of results returned.
            Can be used for paginating the results together with `offset`.
        :param offset: Skip the first `offset` results when paginating.
            Needs to be an integer greater or equal to zero.
            To be used in conjunction with `limit`.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetBillingStatementListRequest(
            paginated=paginated,
            limit=limit,
            offset=offset,
        )

        req = self._build_request(
            method="GET",
            path="/billing/statements",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 60000, 1.5, 3600000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["5XX"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetBillingStatementList",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "401", "422", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.PaginatedBillingStatementResponse, http_res
            )
        if utils.match_response(http_res, ["400", "401", "422"], "application/json"):
            response_data = unmarshal_json_response(models.ClerkErrorsData, http_res)
            raise models.ClerkErrors(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(models.ClerkErrorsData, http_res)
            raise models.ClerkErrors(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)

        raise models.SDKError("Unexpected response received", http_res)

    async def list_statements_async(
        self,
        *,
        paginated: Optional[bool] = None,
        limit: Optional[int] = 10,
        offset: Optional[int] = 0,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PaginatedBillingStatementResponse:
        r"""List all billing statements

        Returns a list of all billing statements for the instance. The statements are returned sorted by creation date,
        with the newest statements appearing first. Pagination is supported.

        :param paginated: Whether to paginate the results.
            If true, the results will be paginated.
            If false, the results will not be paginated.
        :param limit: Applies a limit to the number of results returned.
            Can be used for paginating the results together with `offset`.
        :param offset: Skip the first `offset` results when paginating.
            Needs to be an integer greater or equal to zero.
            To be used in conjunction with `limit`.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetBillingStatementListRequest(
            paginated=paginated,
            limit=limit,
            offset=offset,
        )

        req = self._build_request_async(
            method="GET",
            path="/billing/statements",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 60000, 1.5, 3600000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["5XX"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetBillingStatementList",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "401", "422", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.PaginatedBillingStatementResponse, http_res
            )
        if utils.match_response(http_res, ["400", "401", "422"], "application/json"):
            response_data = unmarshal_json_response(models.ClerkErrorsData, http_res)
            raise models.ClerkErrors(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(models.ClerkErrorsData, http_res)
            raise models.ClerkErrors(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)

        raise models.SDKError("Unexpected response received", http_res)

    def get_statement(
        self,
        *,
        statement_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BillingStatement:
        r"""Retrieve a billing statement

        Retrieves the details of a billing statement.

        :param statement_id: The ID of the statement to retrieve.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetBillingStatementRequest(
            statement_id=statement_id,
        )

        req = self._build_request(
            method="GET",
            path="/billing/statements/{statementID}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 60000, 1.5, 3600000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["5XX"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetBillingStatement",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "401", "404", "422", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BillingStatement, http_res)
        if utils.match_response(
            http_res, ["400", "401", "404", "422"], "application/json"
        ):
            response_data = unmarshal_json_response(models.ClerkErrorsData, http_res)
            raise models.ClerkErrors(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(models.ClerkErrorsData, http_res)
            raise models.ClerkErrors(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)

        raise models.SDKError("Unexpected response received", http_res)

    async def get_statement_async(
        self,
        *,
        statement_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BillingStatement:
        r"""Retrieve a billing statement

        Retrieves the details of a billing statement.

        :param statement_id: The ID of the statement to retrieve.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetBillingStatementRequest(
            statement_id=statement_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/billing/statements/{statementID}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 60000, 1.5, 3600000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["5XX"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetBillingStatement",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "401", "404", "422", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BillingStatement, http_res)
        if utils.match_response(
            http_res, ["400", "401", "404", "422"], "application/json"
        ):
            response_data = unmarshal_json_response(models.ClerkErrorsData, http_res)
            raise models.ClerkErrors(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(models.ClerkErrorsData, http_res)
            raise models.ClerkErrors(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)

        raise models.SDKError("Unexpected response received", http_res)

    def get_statement_payment_attempts(
        self,
        *,
        statement_id: str,
        paginated: Optional[bool] = None,
        limit: Optional[int] = 10,
        offset: Optional[int] = 0,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PaginatedBillingPaymentAttemptResponse:
        r"""List payment attempts for a billing statement

        Returns a list of all payment attempts for a specific billing statement. The payment attempts are returned sorted by creation date,
        with the newest payment attempts appearing first. Pagination is supported.

        :param statement_id: The ID of the statement to retrieve payment attempts for.
        :param paginated: Whether to paginate the results.
            If true, the results will be paginated.
            If false, the results will not be paginated.
        :param limit: Applies a limit to the number of results returned.
            Can be used for paginating the results together with `offset`.
        :param offset: Skip the first `offset` results when paginating.
            Needs to be an integer greater or equal to zero.
            To be used in conjunction with `limit`.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetBillingStatementPaymentAttemptsRequest(
            statement_id=statement_id,
            paginated=paginated,
            limit=limit,
            offset=offset,
        )

        req = self._build_request(
            method="GET",
            path="/billing/statements/{statementID}/payment_attempts",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 60000, 1.5, 3600000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["5XX"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetBillingStatementPaymentAttempts",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "401", "404", "422", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.PaginatedBillingPaymentAttemptResponse, http_res
            )
        if utils.match_response(
            http_res, ["400", "401", "404", "422"], "application/json"
        ):
            response_data = unmarshal_json_response(models.ClerkErrorsData, http_res)
            raise models.ClerkErrors(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(models.ClerkErrorsData, http_res)
            raise models.ClerkErrors(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)

        raise models.SDKError("Unexpected response received", http_res)

    async def get_statement_payment_attempts_async(
        self,
        *,
        statement_id: str,
        paginated: Optional[bool] = None,
        limit: Optional[int] = 10,
        offset: Optional[int] = 0,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PaginatedBillingPaymentAttemptResponse:
        r"""List payment attempts for a billing statement

        Returns a list of all payment attempts for a specific billing statement. The payment attempts are returned sorted by creation date,
        with the newest payment attempts appearing first. Pagination is supported.

        :param statement_id: The ID of the statement to retrieve payment attempts for.
        :param paginated: Whether to paginate the results.
            If true, the results will be paginated.
            If false, the results will not be paginated.
        :param limit: Applies a limit to the number of results returned.
            Can be used for paginating the results together with `offset`.
        :param offset: Skip the first `offset` results when paginating.
            Needs to be an integer greater or equal to zero.
            To be used in conjunction with `limit`.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetBillingStatementPaymentAttemptsRequest(
            statement_id=statement_id,
            paginated=paginated,
            limit=limit,
            offset=offset,
        )

        req = self._build_request_async(
            method="GET",
            path="/billing/statements/{statementID}/payment_attempts",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 60000, 1.5, 3600000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["5XX"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetBillingStatementPaymentAttempts",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "401", "404", "422", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.PaginatedBillingPaymentAttemptResponse, http_res
            )
        if utils.match_response(
            http_res, ["400", "401", "404", "422"], "application/json"
        ):
            response_data = unmarshal_json_response(models.ClerkErrorsData, http_res)
            raise models.ClerkErrors(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(models.ClerkErrorsData, http_res)
            raise models.ClerkErrors(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)

        raise models.SDKError("Unexpected response received", http_res)
